{"compress":true,"commitItems":[["454a2de8-372a-4e25-94b2-14b348a1d43e",1522065003312,"",[[1522064949490,["fangle@fangle-PC",[[1,0,"docker\n===\n\n\ndocker ps 查看docker运行进程\t"]],[0,0],[36,36]]],[1522064951416,["fangle@fangle-PC",[[-1,13,"docker ps 查看docker运行进程\t"]],[13,36],[13,13]]],[1522064959361,["fangle@fangle-PC",[[1,13,"> docker 是一种容器化技术，也就是软件打包技术\n\ndocker 流行的原因：\n\n> docker 可以粗糙地理解为轻量级虚拟机\n\n### docker 常用指令\ndocker -v  查看版本\ndocker images 查看本地 镜像\ndocker rmi 容器id  删除某个镜像 (rmi  remove images)\n\ndocker ps 查看docker运行进程\t\ndocker ps -a 查看所有运行过的容器，包括已经停止的\n\ndocker run foo  运行foo 镜像 如果没有回去远程仓库里面寻找并下载这个镜像\n\ndocker run -p 8080:80 -d daocloud.io/nginx \n-p 端口映射 80端口映射本地的8080 端口\n-d 后台守护进程运行\n此时会返回容器ID \ndocker stop  容器id 停止运行这个容器\n\ndocker cp index.html  容器id://usr/share/nginx/html\n将index.html 拷贝到该容器的目录里\ndocker 在容器内的改变都是暂存的，一旦该容器停止这些改动就会消失。\n\ndocker commit -m 'xxx'  容器id\n保持容器id的改动，该指令会返回一个哈希值， 实际上这个是新生成的容器的id值，也就是说保存一个容器的改动会生成一个新的容器。所以 一般指令 应该在后面加上新的容器名\ndocker commit 'xxx' 当前容器id  新生成的容器镜像名称\n\n\n\n"]],[13,13],[673,673]]],[1522065031485,["fangle@fangle-PC",[[-1,672,"\n"],[1,673,"min"]],[673,673],[675,675]]],[1522065032114,["fangle@fangle-PC",[[-1,672,"min"]],[675,675],[672,672]]],[1522065032640,["fangle@fangle-PC",[[-1,671,"\n"],[1,672,"m"]],[672,672],[671,672]]],[1522065032763,["fangle@fangle-PC",[[1,672,"i"]],[671,672],[671,673]]],[1522065032990,["fangle@fangle-PC",[[1,673,"n"]],[671,673],[671,674]]],[1522065033098,["fangle@fangle-PC",[[1,674,"g"]],[671,674],[671,675]]],[1522065033760,["fangle@fangle-PC",[[1,675,"l"]],[671,675],[671,676]]],[1522065036182,["fangle@fangle-PC",[[-1,671,"mingl"],[1,676,"命令小结"]],[671,676],[675,675]]],[1522065036446,["fangle@fangle-PC",[[1,675,"\n\n"]],[675,675],[676,676]]],[1522065051894,["fangle@fangle-PC",[[-1,676,"\n"],[1,677,"- docker pull 获取images"]],[676,676],[698,698]]],[1522065052486,["fangle@fangle-PC",[[-1,697,"s"]],[698,698],[697,697]]],[1522065053053,["fangle@fangle-PC",[[1,697,"\n\n"]],[697,697],[698,698]]],[1522065061233,["fangle@fangle-PC",[[-1,698,"\n"],[1,699,"- docker build "]],[698,698],[713,713]]],[1522065068192,["fangle@fangle-PC",[[1,713," 创建 image"]],[713,713],[722,722]]],[1522065068584,["fangle@fangle-PC",[[1,722,"\n\n"]],[722,722],[723,723]]],[1522065081501,["fangle@fangle-PC",[[-1,723,"\n"],[1,724,"- docker images 查看本地image"]],[723,723],[748,748]]],[1522065082015,["fangle@fangle-PC",[[1,748,"\n\n"]],[748,748],[749,749]]],[1522065084616,["fangle@fangle-PC",[[-1,749,"\n"]],[749,749],[0,0]]],[1522065084933,["fangle@fangle-PC",[[1,748,"-"]],[0,0],[749,749]]],[1522065086942,["fangle@fangle-PC",[[1,748,"\n"]],[748,748],[749,749]]],[1522065092713,["fangle@fangle-PC",[[1,750," docker 入门"]],[750,750],[760,760]]],[1522065093574,["fangle@fangle-PC",[[-1,758,"入门"]],[760,760],[758,758]]],[1522065094960,["fangle@fangle-PC",[[1,758,"rum"]],[758,758],[761,761]]],[1522065095465,["fangle@fangle-PC",[[-1,760,"m"]],[761,761],[760,760]]],[1522065100393,["fangle@fangle-PC",[[1,760,"n 运行容器"]],[760,760],[766,766]]],[1522065100727,["fangle@fangle-PC",[[1,767,"\n"]],[766,766],[767,767]]],[1522065103868,["fangle@fangle-PC",[[1,767,"\t-"]],[767,767],[769,769]]],[1522065104815,["fangle@fangle-PC",[[-1,767,"\t-"]],[769,769],[767,767]]],[1522065118792,["fangle@fangle-PC",[[-1,767,"\n"],[1,768,"- docker ps 查看运行的容器"]],[767,767],[786,786]]],[1522065121539,["fangle@fangle-PC",[[-1,779,"查看"]],[781,781],[779,779]]],[1522065123342,["fangle@fangle-PC",[[1,779,"列出"]],[779,779],[781,781]]],[1522065125758,["fangle@fangle-PC",[[1,786,"\n\n"]],[786,786],[787,787]]],[1522066685222,["fangle@fangle-PC",[[1,669,"。但是"]],[669,669],[672,672]]],[1522066745530,["fangle@fangle-PC",[[1,672,"commit 主要用来入侵后保护现场，不要使用docker commit 来定制镜像，定制镜像应该使用dockerfile 来完成"]],[672,672],[737,737]]]]]]}