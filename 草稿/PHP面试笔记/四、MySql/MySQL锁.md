MySQL锁机制
===



锁机制用于管理对共享资源的并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。

对于Myisam引擎来说，其锁是表锁并发情况下的读没有问题，但是并发插入时的性能就要差一些。
Innodb支持一致性的非锁定读，行级锁支持，行级锁没有相关的的开销，可以同时得到并发性和一致性。

### 锁的类型

#### 共享锁与排他锁
innodb存储引擎实现了两种标准的行级锁
- 共享锁(s lock)，允许事务读一行数据
- 排他锁(x lock)，允许事务删除或更新一行数据

锁兼容：当一个事务获得行r的共享锁，那么另外的事务就可以立即获得行r的共享锁。这种情况称之为锁兼容。如果事务想获得行r的排他锁，则他必须等待事务释放行r上的共享锁。

#### 意向锁
意向锁：Innodb存储引擎支持多粒度锁定，这种锁定允许行级锁和表级锁同时存在。为了支持不同粒度上进行加锁操作，Innodb存储引擎支持一种额外的锁的方式，称之为意向锁。意向锁是表级锁。

innodb存储引擎支持两种意向锁：
- 意向共享锁(IS Lock)，事务想要获得一个表中的某几行共享锁
- 意向排他锁(IX Lock)，事务想要获得一个表中的某几行排他锁

#### 锁相关指令
- 查看当前请求锁信息
`show engine innodb status\G`
- 手动加共享锁语句
`SELECT...FROM...IN SHARE MODE`
- 手动加排他锁语句
`SELECT...FROM...FOR UPDATR`

### 一致性非锁定读

> 一致性非锁定读 是指Innodb存储引擎通过行多版本控制的方式来读取当前执行时间数据库中的行的数据。如果读取的行正在执行DELETE，UPDATE操作，此时读取操作不会因此等待行上锁的释放，相反Innodb存储引擎会去读取行的一个快照数据。

- 一致性非锁定读是通过Undo段来实现的，读取快照信息是不需要加锁的。
- 非锁定读机制大大提高了数据读取的并发性，在Innodb存储引擎默认设置中，这是默认的读取方式，即读取不会占用和等待表上的锁。
- 不同事务隔离级别下的读取方式不同，并不是每个事务隔离级别下读取都是一致性非锁定读。而且就算都是一致性非锁定读，对快照数据的定义也不同。
- 在Read Committed 和 Repeatable Read隔离级别下，Innodb使用一致性非锁定读。
- 在Read Committed隔离级别下，非一致性读的快照数据，总是读取被锁定行的最新一份快照数据
- 在Repeatable Read 隔离级别下，非一致性读的快照数据，总是读取事务开始时的行数据版本。

#### 快照
>快照数据其实就是当前行数据之前的历史版本，可能有多个版本。一个行可能有不止一个快照数据，我们称这种技术为行多版本技术。由此带来的并发控制，称为多版本并发控制，就是常说的MVCC

#### 手动加锁
由于默认情况下，Innodb引擎的SELECT操作使用一致性非锁定读，也就是说读取是不加锁的。但是在某些情况下，我们需要对读取进行加锁，这个时候就需要我们使用手动加锁语句了。

- 手动加共享锁语句
`SELECT...FROM...IN SHARE MODE`
- 手动加排他锁语句
`SELECT...FROM...FOR UPDATR`

对于一致性非锁定读，即使读取的行已经被加锁了，也是可以读取的。
另外手动加锁语句必须在事务中使用，事务提交后，锁也就释放了。

### 锁带来的问题
通过锁可以实现事务的隔离性问题，使事务可以并发地工作。锁提高了并发，但是却带来3种问题
- 丢失更新
- 脏读
- 不可重复读

### 锁的算法
Innodb中存储引擎行锁有三种算法设计：
- Record Lock
单行记录上的锁
- Gap Lock
间隙锁，锁定一个范围，但不包括记录本身
- Next-Key Lock
Record Lock + Gap Lock ,锁定一个范围，包括记录本身

### 其他相关问题

#### 自增长和锁
在Innodb存储引擎的内存结构中，对每个含自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，执行`SELECT MAX(auto_inc_col) FROM t FOR UPDATE`
插入操作会根据这个计数器值加1赋予自增长列，这种实现方式叫做`AUTO-INC Locking`，这种锁其实是特殊的表锁机制，为了提高插入性能，锁不是在一个事务完成后才释放的，而是在完成对自增长值插入的SQL语句执行后立即释放。
从MySQL5.1.22版本后，Innodb提供了一种轻量级互斥量的自增长实现机制来改善这种做法。

#### 外键和锁
在Innodb存储引擎中，对于一个外键列，如果没有显示地对这个列加索引，Innodb引擎会自动对其加一个索引。因为这样可以避免表锁。

#### 阻塞
因为不同锁之间的兼容性问题，有些时候，一个事务中的锁需要等待另一个事务中的锁释放它占用的资源。这种等待的过程就叫做阻塞。
在Innodb存储引擎中，使用参数`innodb_lock_wait_timeout`来控制等待时间(默认50秒)。默认情况下，Innodb存储引擎不会回滚超时引发的错误异常。除非设置`innodb_rollback_on_timeout`
值得一提的是，Innodb存储引擎在大部分情况下都不会对异常进行回滚，死锁除外。

#### 死锁
死锁只发生在并发的情况，程序如果是串行的，那么是不会发生死锁的。死锁产生的原因是会话之间的资源在互相等待。
大多数的死锁，Innodb引擎可以自己侦测到，不需要人为干预。发现死锁后，Innodb会马上回滚一个事务，这样另一个等待中的事务就能得到被回滚事务的资源，从而解决死锁。
Innodb引擎会自动为外键加索引，不存在外键不存在索引造成的死锁问题。

#### 锁升级
Innodb存储引擎不存在锁升级的问题。在Innodb中一个锁的开销与1000000个锁是一样的，都没有开销。

### 参考文章
- [《MySQL技术内幕：InnoDB存储引擎》](https://baike.baidu.com/item/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/8118300)
[了解innodb锁](https://www.cnblogs.com/janehoo/p/5603983.html)
[mysql的锁--行锁，表锁，乐观锁，悲观锁](https://www.cnblogs.com/deliver/p/5730616.html)
[MySQL InnoDB 锁——官方文档](https://segmentfault.com/a/1190000014071758)
[深入理解SELECT/LOCK IN SHARE MODE和SELECT/ FOR UPDATE](https://blog.csdn.net/cug_jiang126com/article/details/50544728)
[何登成的技术博客--MySQL 加锁处理分析](http://hedengcheng.com/?p=771)