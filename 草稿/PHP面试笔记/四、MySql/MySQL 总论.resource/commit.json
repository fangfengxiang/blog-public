{"compress":true,"commitItems":[["440f5d0f-d257-4ca4-95e9-d19846d9c574",1521167332290,"",[[1521167298917,["fangle@fangle-PC",[[1,0,"MySQL 总论\n===\n\n\nmysql基础\n===\n\n请写出下列mysql 数据类型表示的意义 int0 char16 varchar16 datetime text\n\n### 考点\n- MySQL 数据类型\n- MySQL 基础操作\n- MySQL 存储引擎\n- MySQL 锁机制\n- MySQL 事务处理，存储过程，触发器\n\n### MySQL 数据类型\n#### 整数类型\n- TINYINT  SMALLINT MEDIUMINT INT BIGINT\n- 属性 unsigned\n- 长度 可以为整数指定宽度，例如int(11)，单实际上，对大多数应用是没意义的，它不会超过限制值的合法范围，只会影响显示字符的个数。\n也就是说 例如你设为int(3) 你照样可以存1234,只是你存1 的时候设置零填充会填充为001 保证3位。如果没设置zerofill就不会零填充。\n- int类型不管怎么存都是11，写int3是无意义的\n#### 实数类型\n- FLOAT DOUBLE \nFLOAT DOUBLE 支持使用标准的浮点来进行近似的计算。也就是说要在数据库中做计算的话FLOAT DOUBLE 比DECIMAL 更合适\n- DECIMAL\n可存储比BIGINT还大的整数，可以用于存储精确的小数\n\n#### 字符串类型\n- varchar\n用于存储可变长度的字符串，比定长更省空间\nvarchar 使用1个或两个额外字节记录字符串长度，列长度小于255个字节时使用1个字节表示，否则用两个\n如果存储的内容超出指定长度，会被截断\n- char\nchar 是定长的，根据定义的字符串长度分配足够的空间\nchar 会根据需要采用空格进行填充以方便比较\nchar 适合存储比较短的字符串，或者所有的值都接近同一个长度(例如密码hash后都是32 -> char32 )\nchar 长度超出设定的长度，会被截断\n- text\n- BLOB\n- 总结\n对于经常变更的数据，char比varchar更好，char不容易产生碎片\n对于比较短的列，char比varchar在存储空间上更有效率\n只分配真正的空间，更长的列会消耗更长的空间\n尽量避免使用BLOB和text类型，查询会使用临时表，导致严重的性能开销。\n\n#### 枚举类型\n有时候可以使用枚举替代常用的字符串类型\n把不重复的集合存储成一个预定义集合\n非常紧凑，把列表值压缩到一个或两个字节\n内部存储的是整数\n尽量避免使用数字作为枚举的常量，易混乱。\n排序是按照内部存储的整数来进行排序的\n枚举表会使表大小大大减小\n\n#### 日期和时间类型\n尽量使用timestamp，比datetime 空间效率更高\n用整数存储时间戳格式通常不方便处理\n如果要存储微秒，可以使用bigint存储\n\n### 列属性\n- auto_increment\n- default\n- not null\n- zerofill\n\n### 基础操作\n- mysql  -u -p -h -P\n- \\G 格式化显示 \\c 取消当前命令 \\q 退出 \\s \\h 帮助信息 \\d  \n\n### 引擎\n\n#### innodb\n默认的事务型引擎，最重要最广泛的存储引擎，\t性能非常优秀\n数据存储在共享表空间 ，可以通过配置分开\n对主键查询的性能高于其他类型的存储引擎\n内部做了优化，从磁盘读取数据时自动在内存构建hash索引\n插入数据时自动构建插入缓冲区\n\n通过一些机制和工具实现真正的热备份\n支持奔溃后的安全恢复\n支持行级锁\n支持外键\n\n#### myisam\n5.1以前是默认的引擎\n拥有全文索引，压缩，空间函数\n不支持事务和行级锁，不支持奔溃后的安全恢复\n表不使用共享表空间，表存储在两个文件，MYD（数据文件）和MYI（索引文件）\n设计简单，某些场景下性能很好\n\n#### 其他引擎\nArchive Blackhole CSV Memory\t\n\n### 锁\n#### 锁机制 \n> 当多个查询同一时刻进行数据修改时，就会产生并发控制的问题\n\n- 分为共享锁和排他锁，其实就是读锁和写锁\n- 读锁是共享的，不堵塞，多个用户可以同时读一个资源，互不干扰\n- 写锁是排他的，一个写锁可以阻塞其他写锁和读锁，这样只允许一个人进行写入，防止其他用户读取正在写入的资源\n\n#### 锁粒度\n- 表锁，系统性能开销最小，会锁定整张表，myisam使用表锁\n- 行锁，最大程度地支持并发处理，但是也带来了最大的锁开销，Innodb使用行级锁\n\n### 事务处理\n- mysql提供事务处理的表引擎，Innodb\n- 服务器不管理事务，由下层引擎实现，所以在同一个事务中，使用多种存储引擎是不靠谱的\n- 在非事务的表上执行事务操作，mysql不会提醒也不会报错。\n\n### 存储过程\n- 为以后的使用而保存一条或是多条MySQL语句的集合\n- 存储过程就是有业务逻辑和流程的集合\n- 可以在存储过程中创建表，更新数据，删除等\n- 使用场景 \n通过把处理封装在容易使用的单元里，简化复杂操作\n保证数据的一致性\n简化对变动的管理\n\n### 触发器\n> 提供给程序员和数据分析员来保证数据完整性一种方法，它是与表事件相关的特殊存储过程\n\n- 使用场景\n可通过数据库中的相关表进行级联更改\n实时监控某张表中的某个字段的更改而需要做出相应的处理\n某些业务编号的生成\n滥用会造成数据库及应用程序的维护困难\n\n### 面试题\n请说明表存储引擎Innodb和myisam的区别\n\n\ndelete\n\nInsert into ......  ON DUPLICATE KEY \nupdate 失败 执行 insert\n\n---\n\n"]],[0,0],[2360,2360]]],[1521167309128,["fangle@fangle-PC",[[-1,23,"==="]],[23,26],[23,23]]],[1521167311653,["fangle@fangle-PC",[[1,23,"---"]],[23,23],[26,26]]]]]]}